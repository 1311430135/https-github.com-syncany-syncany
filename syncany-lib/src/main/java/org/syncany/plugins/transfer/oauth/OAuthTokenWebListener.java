package org.syncany.plugins.transfer.oauth;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URI;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.common.collect.Lists;
import com.google.common.collect.Queues;
import com.google.common.collect.Range;
import io.undertow.Handlers;
import io.undertow.Undertow;
import io.undertow.server.HttpServerExchange;
import io.undertow.util.Headers;

/**
 * This class creates a server handling the OAuth callback URLs. It has two tasks. First it is responsible for executing
 * {@link OAuthTokenInterceptor} depending on a path defined by the interceptor itself. Furthermore it does the token
 * parsing in the URL using a {@link OAuthTokenExtractor}.
 *
 * @author Christian Roth <christian.roth@port17.de>
 */

public class OAuthTokenWebListener implements Callable<OAuthTokenFinish> {

	private static final Logger logger = Logger.getLogger(OAuthTokenWebListener.class.getName());
	private static final int PORT_LOWER = 55500;
	private static final int PORT_UPPER = 55599;
	private static final List<InetAddress> ALLOWED_CLIENT_IPS = Lists.newArrayList();

	private final int port;
	private final String id;
	private final SynchronousQueue<Object> ioQueue = Queues.newSynchronousQueue();
	private final OAuthTokenInterceptor interceptor;
	private final OAuthTokenExtractor extractor;
	private final List<InetAddress> allowedClients;

	private Undertow server;

	public static Builder forId(String id) {
		return new Builder(id);
	}

	public static class Builder {

		private final String id;
		private final List<InetAddress> allowedClients = Lists.newArrayList();

		private OAuthTokenInterceptor interceptor = new OAuthTokenInterceptors.RedirectTokenInterceptor();
		private OAuthTokenExtractor extractor = new OAuthTokenExtractors.NamedQueryTokenExtractor();
		private int port;

		private Builder(String id) {
			this.id = id;
			this.port = new Random().nextInt((PORT_UPPER - PORT_LOWER) + 1) + PORT_LOWER;
		}

		/**
		 * Use a custom interceptor (default {@link org.syncany.plugins.transfer.oauth.OAuthTokenInterceptors.RedirectTokenInterceptor})
		 */
		public Builder setTokenInterceptor(OAuthTokenInterceptor interceptor) {
			if (interceptor != null) {
				this.interceptor = interceptor;
			}

			return this;
		}

		/**
		 * Use a custom extractor (default {@link org.syncany.plugins.transfer.oauth.OAuthTokenExtractors.NamedQueryTokenExtractor})
		 */
		public Builder setTokenExtractor(OAuthTokenExtractor extractor) {
			if (extractor != null) {
				this.extractor = extractor;
			}

			return this;
		}

		/**
		 * Use a fixed port, otherwise the port is randomly chosen from a range of {@link OAuthTokenWebListener#PORT_LOWER}
		 * and {@link OAuthTokenWebListener#PORT_UPPER}.
		 *
		 * @param port Fixed port to use
		 *
		 * @throws IllegalArgumentException Thrown if the chosen port is not in the valid port range (1-65535).
		 * @throws IOException Thrown if the chosen port is already taken.
		 */
		public Builder setPort(int port) {
			if (!Range.open(1, 65535).contains(port)) {
				throw new IllegalArgumentException("Invalid port number " + port);
			}

			if (!isPortAvailable(port)) {
				throw new RuntimeException("Token listener tried to use a defined but already taken port " + port);
			}

			this.port = port;
			return this;
		}

		public Builder addAllowedClient(InetAddress... clientIp) {
			allowedClients.addAll(Lists.newArrayList(clientIp));
			return this;
		}

		public OAuthTokenWebListener build() {
			return new OAuthTokenWebListener(id, port, interceptor, extractor, allowedClients);
		}
	}

	private OAuthTokenWebListener(String id, int port, OAuthTokenInterceptor interceptor, OAuthTokenExtractor extractor, List<InetAddress> allowedClients) {
		this.id = id;
		this.port = port;
		this.interceptor = interceptor;
		this.extractor = extractor;
		this.allowedClients = allowedClients;
	}

	/**
	 * Start the server created by the @{link Builder}.
	 *
	 * @return A callback URI which should be used during the OAuth process.
	 *
	 * @throws IOException Thrown if there was an error while starting the server.
	 */
	public URI start() throws IOException {
		createServer();
		return URI.create(String.format("http://localhost:%d/%s/", port, id));
	}

	/**
	 * Get the token generated by the OAuth process. In fact, this class returns a {@link Future} because the token may not
	 * be received by the server when this method is called.
	 *
	 * @return Returns an {@link OAuthTokenFinish} wrapped in a {@link Future}. The {@link OAuthTokenFinish} should at least
	 * contain a token
	 */
	public Future<OAuthTokenFinish> getToken() {
		return Executors.newFixedThreadPool(1).submit(this);
	}

	@Override
	public OAuthTokenFinish call() throws Exception {
		logger.log(Level.INFO, "Waiting for token response");
		String urlWithIdAndToken = (String) ioQueue.take();

		logger.log(Level.INFO, "Parsing token response " + urlWithIdAndToken);

		OAuthTokenFinish tokenResponse = null; // null if parsing failed (user canceled, api error, ...
		try {
			tokenResponse = extractor.parse(urlWithIdAndToken);
			ioQueue.put(OAuthWebResponses.createValidResponse());
		}
		catch (NoSuchFieldException e) {
			logger.log(Level.SEVERE, "Unable to find token in response", e);
			ioQueue.put(OAuthWebResponses.createBadResponse());
		}

		ioQueue.take(); // make sure undertow has send a response

		logger.log(Level.INFO, tokenResponse != null ? "Returning token" : "No token received, returning null");
		return tokenResponse;
	}

	@Override
	public void finalize() throws Throwable {
		super.finalize();

		if (server != null) {
			logger.log(Level.INFO, "Stopping server");
			server.stop();
		}
	}

	private void createServer() {
		logger.log(Level.FINE, "Locked to build server...");

		OAuthTokenInterceptor extractingHttpHandler = new ExtractingTokenInterceptor(ioQueue);

		server = Undertow.builder()
						.addHttpListener(port, "localhost")
						.setHandler(Handlers.path()
														.addExactPath(createPath(extractingHttpHandler.getPathPrefix()), extractingHttpHandler)
														.addExactPath(createPath(interceptor.getPathPrefix()), interceptor)
						)
						.build();

		logger.log(Level.INFO, "Starting token web listener...");
		server.start();
	}

	private String createPath(String prefix) {
		return URI.create(String.format("/%s/%s", id, prefix)).normalize().toString();
	}

	private static boolean isPortAvailable(int port) {
		try (Socket ignored = new Socket("localhost", port)) {
			return false;
		} catch (IOException ignored) {
			return true;
		}
	}

	/**
	 * Default {@link OAuthTokenInterceptor} which notifies the listener about an existing token. It also sends feedback
	 * to a server.
	 */
	static final class ExtractingTokenInterceptor implements OAuthTokenInterceptor {

		public static final String PATH_PREFIX = "/extract";

		private final SynchronousQueue<Object> queue;

		private ExtractingTokenInterceptor(SynchronousQueue<Object> queue) {
			this.queue = queue;
		}

		@Override
		public String getPathPrefix() {
			return PATH_PREFIX;
		}

		@Override
		public void handleRequest(HttpServerExchange exchange) throws Exception {
			String urlWithIdAndToken = exchange.getRequestURL() + "?" + exchange.getQueryString();
			logger.log(Level.INFO, "Got a request to " + urlWithIdAndToken);
			queue.add(urlWithIdAndToken);

			TimeUnit.SECONDS.sleep(2);

			OAuthWebResponse oauthWebResponse = (OAuthWebResponse) queue.take();
			logger.log(Level.INFO, "Got an oauth response with code " + oauthWebResponse.getCode());
			exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, "text/html");
			exchange.setResponseCode(oauthWebResponse.getCode());
			exchange.getResponseSender().send(oauthWebResponse.getBody());
			exchange.endExchange();
			queue.add(Boolean.TRUE);
		}
	}
}

